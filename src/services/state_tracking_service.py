"""
Service for managing entity state transitions.

This module provides business logic for tracking entity states through the processing pipeline.
"""

from datetime import datetime, timedelta
from typing import List, Optional, Union

from src.context.operation_context import operation
from src.context.service_decorators import handle_repository_errors
from src.context.tenant_context import tenant_aware
from src.db.db_base import EntityStateEnum
from src.db.db_state_transition_models import TransitionTypeEnum
from src.repositories.state_transition_repository import StateTransitionRepository
from src.schemas.state_transition_schema import (
    EntityStateHistory,
    StateTransitionCreate,
    StateTransitionFilter,
    StateTransitionRead,
    StateTransitionStats,
    StateTransitionUpdate,
)
from src.services.base_service import BaseService
from src.type_definitions import MessageDict, ProcessorData


class StateTrackingService(
    BaseService[
        StateTransitionCreate, StateTransitionRead, StateTransitionUpdate, StateTransitionFilter
    ]
):
    """
    Service for managing entity state transitions with tenant isolation.

    This service provides methods for recording, retrieving, and analyzing
    state transitions throughout the entity processing pipeline.
    """

    def __init__(self, db_manager):
        """
        Initialize the service with a database manager.

        Args:
            db_manager: Database manager for session handling
        """
        self.db_manager = db_manager
        repository = StateTransitionRepository(db_manager)
        super().__init__(
            repository=repository,
            read_schema_class=StateTransitionRead,
        )

    @tenant_aware
    @operation(name="record_state_transition")
    @handle_repository_errors("record_transition")
    def record_transition(
        self,
        entity_id: str,
        from_state: Union[str, EntityStateEnum],
        to_state: Union[str, EntityStateEnum],
        actor: str,
        transition_type: Union[str, TransitionTypeEnum] = TransitionTypeEnum.NORMAL,
        processor_data: Optional[ProcessorData] = None,
        queue_source: Optional[str] = None,
        queue_destination: Optional[str] = None,
        notes: Optional[str] = None,
        transition_duration: Optional[int] = None,
    ) -> str:
        """
        Record a state transition for an entity.

        Args:
            entity_id: ID of the entity
            from_state: Previous state
            to_state: New state
            actor: Actor (processor or user) making the transition
            transition_type: Type of transition (NORMAL, ERROR, etc.)
            processor_data: Additional data related to the transition
            queue_source: Queue from which the message was received
            queue_destination: Queue to which the message was sent
            notes: Additional notes about the transition
            transition_duration: Duration in ms of the previous state

        Returns:
            ID of the created state transition

        Raises:
            ServiceError: If the transition cannot be recorded
        """
        # Convert enum values to strings if needed
        from_state_val = from_state.value if hasattr(from_state, "value") else from_state
        to_state_val = to_state.value if hasattr(to_state, "value") else to_state
        transition_type_val = (
            transition_type
            if isinstance(transition_type, TransitionTypeEnum)
            else TransitionTypeEnum(transition_type)
        )

        # Create the state transition
        state_transition_data = StateTransitionCreate(
            entity_id=entity_id,
            from_state=from_state_val,
            to_state=to_state_val,
            actor=actor,
            transition_type=transition_type_val,
            processor_data=processor_data,
            queue_source=queue_source,
            queue_destination=queue_destination,
            notes=notes,
            transition_duration=transition_duration,
            sequence_number=None,  # Will be auto-generated by repository
            tenant_id=None,  # Will be set by tenant_aware decorator
        )

        # Record the transition
        return self.repository.create(state_transition_data)

    @tenant_aware
    @operation(name="get_entity_state_history")
    @handle_repository_errors("get_entity_state_history")
    def get_entity_state_history(self, entity_id: str) -> Optional[EntityStateHistory]:
        """
        Get the complete state history for an entity.

        Args:
            entity_id: ID of the entity

        Returns:
            EntityStateHistory with state transition history or None if no history exists

        Raises:
            ServiceError: If the state history cannot be retrieved
        """
        return self.repository.get_entity_state_history(entity_id)

    @tenant_aware
    @operation(name="get_current_state")
    @handle_repository_errors("get_current_state")
    def get_current_state(self, entity_id: str) -> Optional[str]:
        """
        Get the current state of an entity.

        Args:
            entity_id: ID of the entity

        Returns:
            Current state string or None if entity not found

        Raises:
            ServiceError: If the current state cannot be determined
        """
        history = self.repository.get_entity_state_history(entity_id)
        if not history:
            return None

        return history.current_state

    @tenant_aware
    @operation(name="get_entities_in_state")
    @handle_repository_errors("get_entities_in_state")
    def get_entities_in_state(
        self, state: Union[str, EntityStateEnum], limit: int = 100, offset: int = 0
    ) -> List[str]:
        """
        Get entities currently in a specific state.

        Args:
            state: The state to filter by
            limit: Maximum number of results to return
            offset: Number of results to skip

        Returns:
            List of entity IDs in the specified state

        Raises:
            ServiceError: If the entities cannot be retrieved
        """
        state_val = state.value if hasattr(state, "value") else state
        return self.repository.get_entities_in_state(state_val, limit, offset)

    @tenant_aware
    @operation(name="get_stuck_entities")
    @handle_repository_errors("get_stuck_entities")
    def get_stuck_entities(
        self, state: Union[str, EntityStateEnum], threshold_minutes: int = 60, limit: int = 100
    ) -> List[str]:
        """
        Get entities stuck in a state for longer than the threshold.

        Args:
            state: The state to check for stuck entities
            threshold_minutes: Time threshold in minutes
            limit: Maximum number of results to return

        Returns:
            List of entity IDs stuck in the specified state

        Raises:
            ServiceError: If the stuck entities cannot be determined
        """
        state_val = state.value if hasattr(state, "value") else state
        threshold_time = datetime.now() - timedelta(minutes=threshold_minutes)

        # Create filter for finding stuck entities
        filter_params = StateTransitionFilter(
            entity_id=None,
            tenant_id=None,
            from_state=None,
            to_state=state_val,
            actor=None,
            transition_type=None,
            created_after=None,
            created_before=threshold_time,
            updated_after=None,
            updated_before=None,
        )

        # Get transitions matching the filter
        transitions = self.repository.get_by_filter(filter_params=filter_params, limit=limit)

        # Check if these are still the current states
        stuck_entities = []
        for transition in transitions:
            current_state = self.get_current_state(transition.entity_id)
            if current_state == state_val:
                stuck_entities.append(transition.entity_id)

        return stuck_entities

    @tenant_aware
    @operation(name="get_state_statistics")
    @handle_repository_errors("get_state_statistics")
    def get_state_statistics(
        self, start_time: Optional[datetime] = None, end_time: Optional[datetime] = None
    ) -> StateTransitionStats:
        """
        Get statistics about state transitions.

        Args:
            start_time: Optional start time for the statistics period
            end_time: Optional end time for the statistics period

        Returns:
            StateTransitionStats with various metrics

        Raises:
            ServiceError: If the statistics cannot be calculated
        """
        return self.repository.get_state_statistics(start_time=start_time, end_time=end_time)

    @tenant_aware
    @operation(name="calculate_avg_processing_time")
    @handle_repository_errors("calculate_avg_processing_time")
    def calculate_avg_processing_time(
        self,
        start_state: Union[str, EntityStateEnum] = EntityStateEnum.RECEIVED,
        end_state: Union[str, EntityStateEnum] = EntityStateEnum.COMPLETED,
        start_time: Optional[datetime] = None,
        end_time: Optional[datetime] = None,
    ) -> Optional[float]:
        """
        Calculate the average time to process entities from start to end state.

        Args:
            start_state: Initial state in the processing flow
            end_state: Final state in the processing flow
            start_time: Optional start time for the calculation period
            end_time: Optional end time for the calculation period

        Returns:
            Average processing time in milliseconds or None if no data

        Raises:
            ServiceError: If the calculation fails
        """
        stats = self.repository.get_state_statistics(start_time=start_time, end_time=end_time)

        # If we have average durations for all intermediate states,
        # sum them to get total processing time
        start_state_val = start_state.value if hasattr(start_state, "value") else start_state
        end_state_val = end_state.value if hasattr(end_state, "value") else end_state

        # Get all states between start and end from EntityStateEnum
        all_states = [e.value for e in EntityStateEnum]

        # Find start and end indices
        try:
            start_idx = all_states.index(start_state_val)
            end_idx = all_states.index(end_state_val)
        except ValueError:
            self.logger.error(f"Invalid start or end state: {start_state_val}, {end_state_val}")
            return None

        # Get relevant states between start and end
        relevant_states = all_states[start_idx : end_idx + 1]

        # Sum durations for relevant states
        total_duration = 0
        count = 0
        for state in relevant_states:
            if state in stats.avg_duration_by_state:
                total_duration += stats.avg_duration_by_state[state]
                count += 1

        if count == 0:
            return None

        return total_duration

    @operation(name="update_message_with_state")
    def update_message_with_state(
        self, message: MessageDict, state: Union[str, EntityStateEnum]
    ) -> MessageDict:
        """
        Update a message object with a new state.

        This is a utility method for processors to update message state.

        Args:
            message: Message dictionary
            state: New state to set

        Returns:
            Updated message dictionary
        """
        state_val = state.value if hasattr(state, "value") else state

        # Create a copy of the message to avoid modifying the original
        updated_message = message.copy()

        # Update state in the message
        updated_message["state"] = state_val

        # If message has metadata, record state change there too
        if "metadata" in updated_message and isinstance(updated_message["metadata"], dict):
            metadata = updated_message["metadata"].copy()
            metadata["previous_state"] = message.get("state")
            metadata["state_changed_at"] = datetime.now().isoformat()
            updated_message["metadata"] = metadata

        return updated_message
